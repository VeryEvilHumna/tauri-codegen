//! Integration tests for TypeScript code generation

use std::path::PathBuf;
use tauri_ts_generator::config::NamingConfig;
use tauri_ts_generator::generator::{
    commands_gen::generate_commands_file, types_gen::generate_types_file, GeneratorContext,
};
use tauri_ts_generator::models::{
    CommandArg, EnumRepresentation, EnumVariant, RustEnum, RustStruct, RustType, StructField, TauriCommand,
    VariantData,
};
use tauri_ts_generator::parser::{parse_commands, parse_types};

/// Get path to test fixtures
fn fixture_path(name: &str) -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures")
        .join(name)
}

/// Read fixture file content
fn read_fixture(name: &str) -> String {
    std::fs::read_to_string(fixture_path(name)).expect("Failed to read fixture")
}

#[test]
fn test_generate_types_from_simple_fixture() {
    let content = read_fixture("simple_commands.rs");
    let path = fixture_path("simple_commands.rs");

    let (structs, enums) = parse_types(&content, &path).expect("Failed to parse types");

    let mut ctx = GeneratorContext::new(NamingConfig::default());
    for s in &structs {
        ctx.register_type(&s.name);
    }
    for e in &enums {
        ctx.register_type(&e.name);
    }

    let output = generate_types_file(&structs, &enums, &ctx);

    // Check header
    assert!(output.contains("// This file was auto-generated by tauri-ts-generator"));
    assert!(output.contains("// Do not edit this file manually"));

    // Check User interface
    assert!(output.contains("export interface User"));
    assert!(output.contains("id: number"));
    assert!(output.contains("name: string"));
    assert!(output.contains("email: string | null"));

    // Check CreateUserRequest interface
    assert!(output.contains("export interface CreateUserRequest"));

    // Check Status enum
    assert!(output.contains("export type Status"));
    assert!(output.contains("\"Active\""));
    assert!(output.contains("\"Inactive\""));
    assert!(output.contains("\"Pending\""));
}

#[test]
fn test_generate_commands_from_simple_fixture() {
    let content = read_fixture("simple_commands.rs");
    let path = fixture_path("simple_commands.rs");

    let commands = parse_commands(&content, &path).expect("Failed to parse commands");
    let (structs, enums) = parse_types(&content, &path).expect("Failed to parse types");

    let mut ctx = GeneratorContext::new(NamingConfig::default());
    for s in &structs {
        ctx.register_type(&s.name);
    }
    for e in &enums {
        ctx.register_type(&e.name);
    }

    let types_path = PathBuf::from("./types.ts");
    let commands_path = PathBuf::from("./commands.ts");

    let output = generate_commands_file(&commands, &types_path, &commands_path, &ctx);

    // Check header and imports
    assert!(output.contains("// This file was auto-generated by tauri-ts-generator"));
    assert!(output.contains("import { invoke } from \"@tauri-apps/api/core\""));

    // Check greet function
    assert!(output.contains("export async function greet"));
    assert!(output.contains("name: string"));
    assert!(output.contains("Promise<string>"));
    assert!(output.contains("invoke<string>(\"greet\""));

    // Check getUser function (camelCase)
    assert!(output.contains("export async function getUser"));
    assert!(output.contains("id: number"));
    assert!(output.contains("Promise<User>"));

    // Check createUser function
    assert!(output.contains("export async function createUser"));
    assert!(output.contains("request: CreateUserRequest"));

    // Check getAllUsers function
    assert!(output.contains("export async function getAllUsers()"));
    assert!(output.contains("Promise<User[]>"));

    // Check deleteUser function
    assert!(output.contains("export async function deleteUser"));
    assert!(output.contains("Promise<void>"));
}

#[test]
fn test_generate_complex_types() {
    let content = read_fixture("complex_types.rs");
    let path = fixture_path("complex_types.rs");

    let (structs, enums) = parse_types(&content, &path).expect("Failed to parse types");

    let mut ctx = GeneratorContext::new(NamingConfig::default());
    for s in &structs {
        ctx.register_type(&s.name);
    }
    for e in &enums {
        ctx.register_type(&e.name);
    }

    let output = generate_types_file(&structs, &enums, &ctx);

    // Check generic types
    assert!(output.contains("export interface Wrapper<T>"));
    assert!(output.contains("data: T"));
    assert!(output.contains("export interface Pair<K, V>"));
    assert!(output.contains("key: K"));
    assert!(output.contains("value: V"));

    // Check complex nested types
    assert!(output.contains("export interface NestedData"));
    assert!(output.contains("users: (User | null)[]"));
    assert!(output.contains("tags: Record<string, string[]>"));

    // Check complex enum (Message with tuple and struct variants)
    assert!(output.contains("export type Message"));
    // External representation
    assert!(output.contains("Text: string"));
    assert!(output.contains("Image: {"));
}

#[test]
fn test_generate_with_naming_prefix() {
    let structs = vec![RustStruct {
        name: "User".to_string(),
        generics: vec![],
        fields: vec![StructField {
            name: "id".to_string(),
            ty: RustType::Primitive("i32".to_string()),
        }],
        source_file: PathBuf::from("test.rs"),
    }];

    let mut ctx = GeneratorContext::new(NamingConfig {
        type_prefix: "I".to_string(),
        type_suffix: "".to_string(),
        function_prefix: "".to_string(),
        function_suffix: "".to_string(),
    });
    ctx.register_type("User");

    let output = generate_types_file(&structs, &[], &ctx);

    assert!(output.contains("export interface IUser"));
}

#[test]
fn test_generate_with_naming_suffix() {
    let structs = vec![RustStruct {
        name: "User".to_string(),
        generics: vec![],
        fields: vec![],
        source_file: PathBuf::from("test.rs"),
    }];

    let mut ctx = GeneratorContext::new(NamingConfig {
        type_prefix: "".to_string(),
        type_suffix: "DTO".to_string(),
        function_prefix: "".to_string(),
        function_suffix: "".to_string(),
    });
    ctx.register_type("User");

    let output = generate_types_file(&structs, &[], &ctx);

    assert!(output.contains("export interface UserDTO"));
}

#[test]
fn test_generate_command_with_function_prefix_suffix() {
    let commands = vec![TauriCommand {
        name: "get_user".to_string(),
        args: vec![],
        return_type: Some(RustType::Custom("User".to_string())),
        source_file: PathBuf::from("test.rs"),
    }];

    let mut ctx = GeneratorContext::new(NamingConfig {
        type_prefix: "".to_string(),
        type_suffix: "".to_string(),
        function_prefix: "api".to_string(),
        function_suffix: "Cmd".to_string(),
    });
    ctx.register_type("User");

    let types_path = PathBuf::from("./types.ts");
    let commands_path = PathBuf::from("./commands.ts");

    let output = generate_commands_file(&commands, &types_path, &commands_path, &ctx);

    assert!(output.contains("export async function apigetUserCmd"));
}

#[test]
fn test_type_imports_in_commands_file() {
    let commands = vec![
        TauriCommand {
            name: "get_user".to_string(),
            args: vec![],
            return_type: Some(RustType::Custom("User".to_string())),
            source_file: PathBuf::from("test.rs"),
        },
        TauriCommand {
            name: "create_item".to_string(),
            args: vec![CommandArg {
                name: "item".to_string(),
                ty: RustType::Custom("Item".to_string()),
            }],
            return_type: None,
            source_file: PathBuf::from("test.rs"),
        },
    ];

    let mut ctx = GeneratorContext::new(NamingConfig::default());
    ctx.register_type("User");
    ctx.register_type("Item");

    let types_path = PathBuf::from("./types.ts");
    let commands_path = PathBuf::from("./commands.ts");

    let output = generate_commands_file(&commands, &types_path, &commands_path, &ctx);

    // Should import both types
    assert!(output.contains("User"));
    assert!(output.contains("Item"));
    assert!(output.contains("import type {"));
}

#[test]
fn test_empty_types_generates_valid_file() {
    let ctx = GeneratorContext::new(NamingConfig::default());

    let output = generate_types_file(&[], &[], &ctx);

    assert!(output.contains("// This file was auto-generated by tauri-ts-generator"));
    // Should be a valid (though minimal) TypeScript file
    assert!(!output.contains("export interface"));
    assert!(!output.contains("export type"));
}

#[test]
fn test_empty_commands_generates_valid_file() {
    let ctx = GeneratorContext::new(NamingConfig::default());

    let types_path = PathBuf::from("./types.ts");
    let commands_path = PathBuf::from("./commands.ts");

    let output = generate_commands_file(&[], &types_path, &commands_path, &ctx);

    assert!(output.contains("// This file was auto-generated by tauri-ts-generator"));
    assert!(output.contains("import { invoke } from \"@tauri-apps/api/core\""));
    // No functions should be generated
    assert!(!output.contains("export async function"));
}

#[test]
fn test_snake_case_fields_converted_to_camel_case() {
    let structs = vec![RustStruct {
        name: "User".to_string(),
        generics: vec![],
        fields: vec![
            StructField {
                name: "user_id".to_string(),
                ty: RustType::Primitive("i32".to_string()),
            },
            StructField {
                name: "first_name".to_string(),
                ty: RustType::Primitive("String".to_string()),
            },
            StructField {
                name: "last_login_at".to_string(),
                ty: RustType::Primitive("DateTime".to_string()),
            },
        ],
        source_file: PathBuf::from("test.rs"),
    }];

    let ctx = GeneratorContext::new(NamingConfig::default());

    let output = generate_types_file(&structs, &[], &ctx);

    assert!(output.contains("userId: number"));
    assert!(output.contains("firstName: string"));
    assert!(output.contains("lastLoginAt: string"));

    // Should NOT contain snake_case
    assert!(!output.contains("user_id:"));
    assert!(!output.contains("first_name:"));
    assert!(!output.contains("last_login_at:"));
}

#[test]
fn test_complex_enum_discriminated_union() {
    let enums = vec![RustEnum {
        name: "Event".to_string(),
        generics: vec![],
        variants: vec![
            EnumVariant {
                name: "Click".to_string(),
                data: VariantData::Struct(vec![
                    StructField {
                        name: "x".to_string(),
                        ty: RustType::Primitive("i32".to_string()),
                    },
                    StructField {
                        name: "y".to_string(),
                        ty: RustType::Primitive("i32".to_string()),
                    },
                ]),
            },
            EnumVariant {
                name: "KeyPress".to_string(),
                data: VariantData::Tuple(vec![RustType::Primitive("String".to_string())]),
            },
            EnumVariant {
                name: "Close".to_string(),
                data: VariantData::Unit,
            },
        ],
        source_file: PathBuf::from("test.rs"),
        representation: EnumRepresentation::default(),
    }];

    let ctx = GeneratorContext::new(NamingConfig::default());

    let output = generate_types_file(&[], &enums, &ctx);

    assert!(output.contains("export type Event"));
    // External representation
    // Click: { x: number, y: number }
    assert!(output.contains("Click: {"));
    assert!(output.contains("x: number"));
    
    // KeyPress: string
    assert!(output.contains("KeyPress: string"));
    
    // Close (unit variant) -> "Close"
    assert!(output.contains("\"Close\""));
}

