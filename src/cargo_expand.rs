//! Cargo expand support for parsing macro-generated types
//!
//! This module provides functionality to run `cargo expand` and parse
//! the expanded Rust code to extract types generated by macros.

use anyhow::{Context, Result};
use std::path::{Path, PathBuf};
use std::process::Command;

/// Result of cargo expand execution
pub struct ExpandResult {
    /// Expanded Rust code
    pub code: String,
    /// Warnings generated during expansion
    pub warnings: Vec<String>,
}

/// Check if cargo-expand is installed
pub fn is_cargo_expand_available() -> bool {
    Command::new("cargo")
        .args(["expand", "--version"])
        .output()
        .map(|output| output.status.success())
        .unwrap_or(false)
}

/// Run cargo expand on a crate and return the expanded code
pub fn run_cargo_expand(manifest_path: &Path) -> Result<ExpandResult> {
    let mut warnings = Vec::new();

    // Check if cargo-expand is available
    if !is_cargo_expand_available() {
        warnings.push(
            "Warning: cargo-expand is not installed. Install it with: cargo install cargo-expand"
                .to_string(),
        );
        return Ok(ExpandResult {
            code: String::new(),
            warnings,
        });
    }

    warnings.push(format!(
        "Warning: Using cargo expand on {}. This may take a while...",
        manifest_path.display()
    ));

    // Build the cargo expand command
    let mut cmd = Command::new("cargo");
    cmd.args(["expand", "--lib"]);

    // Add manifest path if specified
    if manifest_path.file_name() == Some(std::ffi::OsStr::new("Cargo.toml")) {
        cmd.arg("--manifest-path").arg(manifest_path);
    } else {
        // Assume it's a directory, look for Cargo.toml
        let cargo_toml = manifest_path.join("Cargo.toml");
        if cargo_toml.exists() {
            cmd.arg("--manifest-path").arg(&cargo_toml);
        } else {
            warnings.push(format!(
                "Warning: Cargo.toml not found at {}",
                cargo_toml.display()
            ));
            return Ok(ExpandResult {
                code: String::new(),
                warnings,
            });
        }
    }

    // Run cargo expand
    let output = cmd
        .output()
        .with_context(|| "Failed to execute cargo expand")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        warnings.push(format!(
            "Warning: cargo expand failed with status {}: {}",
            output.status, stderr
        ));
        return Ok(ExpandResult {
            code: String::new(),
            warnings,
        });
    }

    let code = String::from_utf8_lossy(&output.stdout).to_string();
    
    // Add success message
    let line_count = code.lines().count();
    warnings.push(format!(
        "Info: cargo expand completed successfully ({} lines of expanded code)",
        line_count
    ));

    Ok(ExpandResult { code, warnings })
}

/// Find Cargo.toml by walking up from source directory
pub fn find_cargo_manifest(source_dir: &Path) -> Option<PathBuf> {
    let mut current = source_dir;
    
    loop {
        let cargo_toml = current.join("Cargo.toml");
        if cargo_toml.exists() {
            return Some(cargo_toml);
        }
        
        match current.parent() {
            Some(parent) => current = parent,
            None => return None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_find_cargo_manifest_in_current() {
        // Create a temp dir structure
        let temp = tempfile::tempdir().unwrap();
        let src_dir = temp.path().join("src");
        std::fs::create_dir_all(&src_dir).unwrap();
        
        // Create Cargo.toml in temp root
        std::fs::write(temp.path().join("Cargo.toml"), "[package]\nname = \"test\"").unwrap();
        
        let result = find_cargo_manifest(&src_dir);
        assert!(result.is_some());
        assert_eq!(result.unwrap(), temp.path().join("Cargo.toml"));
    }

    #[test]
    fn test_find_cargo_manifest_not_found() {
        let result = find_cargo_manifest(Path::new("/nonexistent/path"));
        assert!(result.is_none());
    }

    #[test]
    fn test_is_cargo_expand_available() {
        // This test just checks that the function doesn't panic
        let _available = is_cargo_expand_available();
    }
}

