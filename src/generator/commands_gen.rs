use crate::models::{CommandArg, RustType, TauriCommand};
use crate::utils::to_camel_case;
use std::collections::HashSet;
use std::path::Path;

use super::{type_mapper::rust_to_typescript, GeneratorContext};

/// Generate TypeScript commands file content
pub fn generate_commands_file(
    commands: &[TauriCommand],
    types_file_path: &Path,
    commands_file_path: &Path,
    ctx: &GeneratorContext,
) -> String {
    let mut output = String::new();

    // Add header comment
    output.push_str("// This file was auto-generated by tauri-ts-generator\n");
    output.push_str("// Do not edit this file manually\n\n");

    // Add Tauri import
    output.push_str("import { invoke } from \"@tauri-apps/api/core\";\n");

    // Collect all custom types used in commands
    let used_types = collect_used_types(commands, ctx);

    if !used_types.is_empty() {
        // Calculate relative import path from commands file to types file
        let import_path = calculate_relative_import(types_file_path, commands_file_path);
        let mut types_list: Vec<_> = used_types.into_iter().collect();
        types_list.sort();
        output.push_str(&format!(
            "import type {{ {} }} from \"{}\";\n",
            types_list.join(", "),
            import_path
        ));
    }

    output.push('\n');

    // Generate function for each command
    for cmd in commands {
        output.push_str(&generate_command_function(cmd, ctx));
        output.push('\n');
    }

    output
}

/// Collect all custom type names used in commands
fn collect_used_types(commands: &[TauriCommand], ctx: &GeneratorContext) -> HashSet<String> {
    let mut types = HashSet::new();

    for cmd in commands {
        // Check arguments
        for arg in &cmd.args {
            collect_types_from_rust_type(&arg.ty, ctx, &mut types);
        }

        // Check return type
        if let Some(ret_type) = &cmd.return_type {
            collect_types_from_rust_type(ret_type, ctx, &mut types);
        }
    }

    types
}

/// Recursively collect custom type names from a RustType
fn collect_types_from_rust_type(ty: &RustType, ctx: &GeneratorContext, types: &mut HashSet<String>) {
    match ty {
        RustType::Custom(name) if ctx.is_custom_type(name) => {
            types.insert(ctx.format_type_name(name));
        }
        RustType::Vec(inner) => collect_types_from_rust_type(inner, ctx, types),
        RustType::Option(inner) => collect_types_from_rust_type(inner, ctx, types),
        RustType::Result(ok) => {
            collect_types_from_rust_type(ok, ctx, types);
        }
        RustType::HashMap { key, value } => {
            collect_types_from_rust_type(key, ctx, types);
            collect_types_from_rust_type(value, ctx, types);
        }
        RustType::Tuple(types_vec) => {
            for t in types_vec {
                collect_types_from_rust_type(t, ctx, types);
            }
        }
        _ => {}
    }
}

/// Generate a TypeScript function for a Tauri command
fn generate_command_function(cmd: &TauriCommand, ctx: &GeneratorContext) -> String {
    let mut output = String::new();

    // Function name in camelCase
    let fn_name = to_camel_case(&cmd.name);
    let fn_name = ctx.format_function_name(&fn_name);

    // Generate parameter list
    let params = generate_params(&cmd.args, ctx);

    // Generate return type
    let return_type = generate_return_type(&cmd.return_type, ctx);

    // Generate function signature
    output.push_str(&format!(
        "export async function {}({}): Promise<{}> {{\n",
        fn_name, params, return_type
    ));

    // Generate invoke call
    if cmd.args.is_empty() {
        output.push_str(&format!(
            "  return invoke<{}>(\"{}\");\n",
            return_type, cmd.name
        ));
    } else {
        let args_obj = generate_args_object(&cmd.args);
        output.push_str(&format!(
            "  return invoke<{}>(\"{}\", {{ {} }});\n",
            return_type, cmd.name, args_obj
        ));
    }

    output.push_str("}\n");

    output
}

/// Generate TypeScript parameter list
fn generate_params(args: &[CommandArg], ctx: &GeneratorContext) -> String {
    args.iter()
        .map(|arg| {
            let param_name = to_camel_case(&arg.name);
            let param_type = rust_to_typescript(&arg.ty, ctx);
            format!("{}: {}", param_name, param_type)
        })
        .collect::<Vec<_>>()
        .join(", ")
}

/// Generate TypeScript return type
fn generate_return_type(return_type: &Option<RustType>, ctx: &GeneratorContext) -> String {
    match return_type {
        Some(ty) => rust_to_typescript(ty, ctx),
        None => "void".to_string(),
    }
}

/// Generate the arguments object for invoke
fn generate_args_object(args: &[CommandArg]) -> String {
    args.iter()
        .map(|arg| {
            let param_name = to_camel_case(&arg.name);
            // If the Rust name (snake_case) differs from camelCase, use object shorthand
            if arg.name == param_name {
                param_name
            } else {
                // Need to map camelCase param to snake_case key
                format!("{}: {}", arg.name, param_name)
            }
        })
        .collect::<Vec<_>>()
        .join(", ")
}

/// Calculate relative import path from commands file to types file
fn calculate_relative_import(types_file: &Path, commands_file: &Path) -> String {
    // Get the directory of the commands file
    let commands_dir = commands_file.parent().unwrap_or(Path::new("."));
    let types_dir = types_file.parent().unwrap_or(Path::new("."));
    let types_name = types_file.file_stem().unwrap_or_default().to_string_lossy();

    // If same directory, just use ./filename
    if commands_dir == types_dir {
        return format!("./{}", types_name);
    }

    // Try to strip prefix (types_file is inside commands_dir)
    if let Ok(relative) = types_file.strip_prefix(commands_dir) {
        let path = relative.with_extension("");
        let path_str = path.to_string_lossy();
        if path_str.starts_with('.') {
            return path_str.to_string();
        } else {
            return format!("./{}", path_str);
        }
    }

    // Compute relative path by finding common ancestor
    let commands_components: Vec<_> = commands_dir.components().collect();
    let types_components: Vec<_> = types_dir.components().collect();

    // Find common prefix length
    let common_len = commands_components
        .iter()
        .zip(types_components.iter())
        .take_while(|(a, b)| a == b)
        .count();

    // Calculate how many ".." we need to go up from commands_dir
    let up_count = commands_components.len() - common_len;

    // Build the path: ../../../path/to/types_file
    let mut result = String::new();
    
    if up_count == 0 {
        result.push_str("./");
    } else {
        for _ in 0..up_count {
            result.push_str("../");
        }
    }

    // Add remaining path components from types file
    for component in types_components.iter().skip(common_len) {
        result.push_str(&component.as_os_str().to_string_lossy());
        result.push('/');
    }

    // Add the filename without extension
    result.push_str(&types_name);

    // Clean up trailing slash if needed
    result.trim_end_matches('/').to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::NamingConfig;
    use std::path::PathBuf;

    fn test_path() -> PathBuf {
        PathBuf::from("test.rs")
    }

    fn default_ctx() -> GeneratorContext {
        GeneratorContext::new(NamingConfig::default())
    }

    fn ctx_with_type(type_name: &str) -> GeneratorContext {
        let mut ctx = default_ctx();
        ctx.register_type(type_name);
        ctx
    }

    #[test]
    fn test_generate_simple_command() {
        let cmd = TauriCommand {
            name: "get_user".to_string(),
            args: vec![CommandArg {
                name: "id".to_string(),
                ty: RustType::Primitive("i32".to_string()),
            }],
            return_type: Some(RustType::Custom("User".to_string())),
            source_file: test_path(),
        };

        let mut ctx = default_ctx();
        ctx.register_type("User");

        let output = generate_command_function(&cmd, &ctx);

        assert!(output.contains("export async function getUser"));
        assert!(output.contains("id: number"));
        assert!(output.contains("Promise<User>"));
        assert!(output.contains("invoke<User>(\"get_user\""));
    }

    #[test]
    fn test_generate_command_no_args() {
        let cmd = TauriCommand {
            name: "get_all".to_string(),
            args: vec![],
            return_type: Some(RustType::Vec(Box::new(RustType::Custom("Item".to_string())))),
            source_file: test_path(),
        };

        let ctx = ctx_with_type("Item");
        let output = generate_command_function(&cmd, &ctx);

        assert!(output.contains("export async function getAll()"));
        assert!(output.contains("Promise<Item[]>"));
        assert!(output.contains("invoke<Item[]>(\"get_all\")"));
        // Should NOT have second argument to invoke
        assert!(!output.contains("invoke<Item[]>(\"get_all\", {"));
    }

    #[test]
    fn test_generate_command_multiple_args() {
        let cmd = TauriCommand {
            name: "create_user".to_string(),
            args: vec![
                CommandArg {
                    name: "name".to_string(),
                    ty: RustType::Primitive("String".to_string()),
                },
                CommandArg {
                    name: "age".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
                CommandArg {
                    name: "email".to_string(),
                    ty: RustType::Option(Box::new(RustType::Primitive("String".to_string()))),
                },
            ],
            return_type: Some(RustType::Custom("User".to_string())),
            source_file: test_path(),
        };

        let ctx = ctx_with_type("User");
        let output = generate_command_function(&cmd, &ctx);

        assert!(output.contains("name: string"));
        assert!(output.contains("age: number"));
        assert!(output.contains("email: string | null"));
    }

    #[test]
    fn test_generate_void_return() {
        let cmd = TauriCommand {
            name: "delete_user".to_string(),
            args: vec![CommandArg {
                name: "id".to_string(),
                ty: RustType::Primitive("i32".to_string()),
            }],
            return_type: None,
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_command_function(&cmd, &ctx);

        assert!(output.contains("Promise<void>"));
        assert!(output.contains("invoke<void>"));
    }

    #[test]
    fn test_camel_case_function_name() {
        let cmd = TauriCommand {
            name: "get_user_by_id".to_string(),
            args: vec![],
            return_type: None,
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_command_function(&cmd, &ctx);

        assert!(output.contains("export async function getUserById()"));
    }

    #[test]
    fn test_snake_case_args_in_invoke() {
        let cmd = TauriCommand {
            name: "update".to_string(),
            args: vec![CommandArg {
                name: "user_id".to_string(),
                ty: RustType::Primitive("i32".to_string()),
            }],
            return_type: None,
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_command_function(&cmd, &ctx);

        // Param should be camelCase
        assert!(output.contains("userId: number"));
        // But invoke should map back to snake_case
        assert!(output.contains("user_id: userId"));
    }

    #[test]
    fn test_collect_used_types_from_commands() {
        let commands = vec![
            TauriCommand {
                name: "get_user".to_string(),
                args: vec![],
                return_type: Some(RustType::Custom("User".to_string())),
                source_file: test_path(),
            },
            TauriCommand {
                name: "create".to_string(),
                args: vec![CommandArg {
                    name: "req".to_string(),
                    ty: RustType::Custom("CreateRequest".to_string()),
                }],
                return_type: Some(RustType::Custom("User".to_string())),
                source_file: test_path(),
            },
        ];

        let mut ctx = default_ctx();
        ctx.register_type("User");
        ctx.register_type("CreateRequest");

        let types = collect_used_types(&commands, &ctx);

        assert!(types.contains("User"));
        assert!(types.contains("CreateRequest"));
        assert_eq!(types.len(), 2);
    }

    #[test]
    fn test_collect_used_types_nested() {
        let commands = vec![TauriCommand {
            name: "get".to_string(),
            args: vec![],
            return_type: Some(RustType::Vec(Box::new(RustType::Option(Box::new(
                RustType::Custom("User".to_string()),
            ))))),
            source_file: test_path(),
        }];

        let ctx = ctx_with_type("User");
        let types = collect_used_types(&commands, &ctx);

        assert!(types.contains("User"));
    }

    #[test]
    fn test_relative_import_path_same_dir() {
        let types_file = Path::new("src/generated/types.ts");
        let commands_file = Path::new("src/generated/commands.ts");

        let import = calculate_relative_import(types_file, commands_file);
        assert_eq!(import, "./types");
    }

    #[test]
    fn test_naming_function_prefix() {
        let cmd = TauriCommand {
            name: "get_user".to_string(),
            args: vec![],
            return_type: None,
            source_file: test_path(),
        };

        let ctx = GeneratorContext::new(NamingConfig {
            type_prefix: "".to_string(),
            type_suffix: "".to_string(),
            function_prefix: "api".to_string(),
            function_suffix: "".to_string(),
        });

        let output = generate_command_function(&cmd, &ctx);
        assert!(output.contains("export async function apigetUser"));
    }

    #[test]
    fn test_naming_function_suffix() {
        let cmd = TauriCommand {
            name: "get_user".to_string(),
            args: vec![],
            return_type: None,
            source_file: test_path(),
        };

        let ctx = GeneratorContext::new(NamingConfig {
            type_prefix: "".to_string(),
            type_suffix: "".to_string(),
            function_prefix: "".to_string(),
            function_suffix: "Cmd".to_string(),
        });

        let output = generate_command_function(&cmd, &ctx);
        assert!(output.contains("export async function getUserCmd"));
    }

    #[test]
    fn test_generate_commands_file_header() {
        let commands: Vec<TauriCommand> = vec![];
        let types_path = Path::new("types.ts");
        let commands_path = Path::new("commands.ts");
        let ctx = default_ctx();

        let output = generate_commands_file(&commands, types_path, commands_path, &ctx);

        assert!(output.contains("// This file was auto-generated by tauri-ts-generator"));
        assert!(output.contains("// Do not edit this file manually"));
        assert!(output.contains("import { invoke } from \"@tauri-apps/api/core\""));
    }

    #[test]
    fn test_generate_commands_file_with_imports() {
        let commands = vec![TauriCommand {
            name: "get_user".to_string(),
            args: vec![],
            return_type: Some(RustType::Custom("User".to_string())),
            source_file: test_path(),
        }];

        let types_path = Path::new("src/generated/types.ts");
        let commands_path = Path::new("src/generated/commands.ts");
        let ctx = ctx_with_type("User");

        let output = generate_commands_file(&commands, types_path, commands_path, &ctx);

        assert!(output.contains("import type { User } from"));
    }

    #[test]
    fn test_complex_return_type() {
        let cmd = TauriCommand {
            name: "search".to_string(),
            args: vec![],
            return_type: Some(RustType::Result(Box::new(RustType::Vec(Box::new(
                RustType::Custom("User".to_string()),
            ))))),
            source_file: test_path(),
        };

        let ctx = ctx_with_type("User");
        let output = generate_command_function(&cmd, &ctx);

        assert!(output.contains("Promise<User[]>"));
    }

    #[test]
    fn test_imports_are_sorted() {
        let commands = vec![TauriCommand {
            name: "test".to_string(),
            args: vec![
                CommandArg {
                    name: "a".to_string(),
                    ty: RustType::Custom("BType".to_string()),
                },
                CommandArg {
                    name: "b".to_string(),
                    ty: RustType::Custom("AType".to_string()),
                },
                CommandArg {
                    name: "c".to_string(),
                    ty: RustType::Custom("CType".to_string()),
                },
            ],
            return_type: None,
            source_file: test_path(),
        }];

        let types_path = Path::new("types.ts");
        let commands_path = Path::new("commands.ts");
        let mut ctx = default_ctx();
        ctx.register_type("AType");
        ctx.register_type("BType");
        ctx.register_type("CType");

        let output = generate_commands_file(&commands, types_path, commands_path, &ctx);

        // Should be AType, BType, CType
        assert!(output.contains("import type { AType, BType, CType }"));
    }
}
