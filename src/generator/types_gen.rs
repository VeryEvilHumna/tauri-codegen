use crate::models::{EnumRepresentation, RustEnum, RustStruct, VariantData};
use crate::utils::to_camel_case;

use super::{type_mapper::rust_to_typescript, GeneratorContext};

/// Generate TypeScript types file content
pub fn generate_types_file(
    structs: &[RustStruct],
    enums: &[RustEnum],
    ctx: &GeneratorContext,
) -> String {
    let mut output = String::new();

    // Add header comment
    output.push_str("// This file was auto-generated by tauri-ts-generator\n");
    output.push_str("// Do not edit this file manually\n\n");

    // Generate interfaces for structs
    for s in structs {
        output.push_str(&generate_interface(s, ctx));
        output.push('\n');
    }

    // Generate types for enums
    for e in enums {
        output.push_str(&generate_enum_type(e, ctx));
        output.push('\n');
    }

    output
}

/// Generate a TypeScript interface from a Rust struct
fn generate_interface(s: &RustStruct, ctx: &GeneratorContext) -> String {
    let mut output = String::new();

    let interface_name = ctx.format_type_name(&s.name);

    // Add generic parameters if present
    let generics_str = if s.generics.is_empty() {
        String::new()
    } else {
        format!("<{}>", s.generics.join(", "))
    };

    output.push_str(&format!(
        "export interface {}{} {{\n",
        interface_name, generics_str
    ));

    for field in &s.fields {
        let ts_type = rust_to_typescript(&field.ty, ctx);
        let field_name = to_camel_case(&field.name);
        output.push_str(&format!("  {}: {};\n", field_name, ts_type));
    }

    output.push_str("}\n");

    output
}

/// Generate a TypeScript type from a Rust enum
fn generate_enum_type(e: &RustEnum, ctx: &GeneratorContext) -> String {
    let mut output = String::new();

    let type_name = ctx.format_type_name(&e.name);

    // Add generic parameters if present
    let generics_str = if e.generics.is_empty() {
        String::new()
    } else {
        format!("<{}>", e.generics.join(", "))
    };

    let variants: Vec<String> = e
        .variants
        .iter()
        .map(|variant| generate_variant(variant, &e.representation, ctx))
        .collect();

    if variants.is_empty() {
        output.push_str(&format!(
            "export type {}{} = never;\n",
            type_name, generics_str
        ));
    } else {
        output.push_str(&format!(
            "export type {}{} =\n  | {};\n",
            type_name,
            generics_str,
            variants.join("\n  | ")
        ));
    }

    output
}

fn generate_variant(
    variant: &crate::models::EnumVariant,
    representation: &EnumRepresentation,
    ctx: &GeneratorContext,
) -> String {
    match representation {
        EnumRepresentation::External => match &variant.data {
            VariantData::Unit => format!("\"{}\"", variant.name),
            VariantData::Tuple(types) => {
                let ts_types: Vec<_> = types.iter().map(|t| rust_to_typescript(t, ctx)).collect();
                let inner = if ts_types.len() == 1 {
                    ts_types[0].clone()
                } else {
                    format!("[{}]", ts_types.join(", "))
                };
                format!("{{ {}: {} }}", variant.name, inner)
            }
            VariantData::Struct(fields) => {
                let inner = generate_struct_body(fields, ctx);
                format!("{{ {}: {} }}", variant.name, inner)
            }
        },
        EnumRepresentation::Internal { tag } => match &variant.data {
            VariantData::Unit => format!("{{ {}: \"{}\" }}", tag, variant.name),
            VariantData::Struct(fields) => {
                let mut body = generate_struct_body(fields, ctx);
                // Remove opening brace and insert tag
                body.remove(0); // remove '{'
                format!("{{ {}: \"{}\",{}", tag, variant.name, body)
            }
            VariantData::Tuple(_) => {
                // Internal tagging doesn't support tuples strictly speaking (unless newtype around struct)
                // We'll fallback to just the tag for now or maybe error?
                // For safety let's just emit { tag: "Name" } & Partial<Tuple> ??
                // Let's assume user knows what they are doing and it's likely not used with Tuples
                format!("{{ {}: \"{}\" /* Tuple variants not fully supported in internal tagging */ }}", tag, variant.name)
            }
        },
        EnumRepresentation::Adjacent { tag, content } => match &variant.data {
            VariantData::Unit => format!("{{ {}: \"{}\" }}", tag, variant.name),
            VariantData::Tuple(types) => {
                let ts_types: Vec<_> = types.iter().map(|t| rust_to_typescript(t, ctx)).collect();
                let inner = if ts_types.len() == 1 {
                    ts_types[0].clone()
                } else {
                    format!("[{}]", ts_types.join(", "))
                };
                format!("{{ {}: \"{}\"; {}: {} }}", tag, variant.name, content, inner)
            }
            VariantData::Struct(fields) => {
                let inner = generate_struct_body(fields, ctx);
                format!("{{ {}: \"{}\"; {}: {} }}", tag, variant.name, content, inner)
            }
        },
        EnumRepresentation::Untagged => match &variant.data {
            VariantData::Unit => "null".to_string(), // Untagged unit matches null? Or nothing? Serde says it errors if it can't match. Usually untagged is for matching shapes.
            VariantData::Tuple(types) => {
                 let ts_types: Vec<_> = types.iter().map(|t| rust_to_typescript(t, ctx)).collect();
                 if ts_types.len() == 1 {
                     ts_types[0].clone()
                 } else {
                     format!("[{}]", ts_types.join(", "))
                 }
            }
            VariantData::Struct(fields) => generate_struct_body(fields, ctx),
        },
    }
}

fn generate_struct_body(fields: &[crate::models::StructField], ctx: &GeneratorContext) -> String {
    let mut params = Vec::new();
    for field in fields {
        let ts_type = rust_to_typescript(&field.ty, ctx);
        let field_name = to_camel_case(&field.name);
        params.push(format!("{}: {}", field_name, ts_type));
    }
    format!("{{ {} }}", params.join("; "))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::NamingConfig;
    use crate::models::{EnumVariant, RustType, StructField, VariantData};
    use std::path::PathBuf;

    fn test_path() -> PathBuf {
        PathBuf::from("test.rs")
    }

    fn default_ctx() -> GeneratorContext {
        GeneratorContext::new(NamingConfig::default())
    }

    #[test]
    fn test_generate_simple_interface() {
        let s = RustStruct {
            name: "User".to_string(),
            generics: vec![],
            fields: vec![
                StructField {
                    name: "id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
                StructField {
                    name: "name".to_string(),
                    ty: RustType::Primitive("String".to_string()),
                },
            ],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface User"));
        assert!(output.contains("id: number"));
        assert!(output.contains("name: string"));
    }

    #[test]
    fn test_generate_interface_with_generics() {
        let s = RustStruct {
            name: "Wrapper".to_string(),
            generics: vec!["T".to_string()],
            fields: vec![
                StructField {
                    name: "data".to_string(),
                    ty: RustType::Generic("T".to_string()),
                },
                StructField {
                    name: "count".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
            ],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface Wrapper<T>"));
        assert!(output.contains("data: T"));
        assert!(output.contains("count: number"));
    }

    #[test]
    fn test_generate_interface_with_multiple_generics() {
        let s = RustStruct {
            name: "Pair".to_string(),
            generics: vec!["K".to_string(), "V".to_string()],
            fields: vec![
                StructField {
                    name: "key".to_string(),
                    ty: RustType::Generic("K".to_string()),
                },
                StructField {
                    name: "value".to_string(),
                    ty: RustType::Generic("V".to_string()),
                },
            ],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface Pair<K, V>"));
    }

    #[test]
    fn test_generate_simple_enum() {
        let e = RustEnum {
            name: "Status".to_string(),
            generics: vec![],
            variants: vec![
                EnumVariant {
                    name: "Active".to_string(),
                    data: VariantData::Unit,
                },
                EnumVariant {
                    name: "Inactive".to_string(),
                    data: VariantData::Unit,
                },
                EnumVariant {
                    name: "Pending".to_string(),
                    data: VariantData::Unit,
                },
            ],
            source_file: test_path(),
            representation: EnumRepresentation::default(),
        };

        let ctx = default_ctx();
        let output = generate_enum_type(&e, &ctx);

        assert!(output.contains("export type Status ="));
        assert!(output.contains("\"Active\""));
        assert!(output.contains("\"Inactive\""));
        assert!(output.contains("\"Pending\""));
    }

    #[test]
    fn test_generate_complex_enum_with_tuple() {
        let e = RustEnum {
            name: "Message".to_string(),
            generics: vec![],
            variants: vec![
                EnumVariant {
                    name: "Text".to_string(),
                    data: VariantData::Tuple(vec![RustType::Primitive("String".to_string())]),
                },
                EnumVariant {
                    name: "Number".to_string(),
                    data: VariantData::Tuple(vec![RustType::Primitive("i32".to_string())]),
                },
            ],
            source_file: test_path(),
            representation: EnumRepresentation::default(),
        };

        let ctx = default_ctx();
        let output = generate_enum_type(&e, &ctx);
        
        assert!(output.contains("export type Message ="));
        // External representation: { Text: string } | { Number: number }
        assert!(output.contains("Text: string"));
        assert!(output.contains("Number: number"));
    }

    #[test]
    fn test_generate_complex_enum_with_struct() {
        let e = RustEnum {
            name: "UserRole".to_string(),
            generics: vec![],
            variants: vec![
                EnumVariant {
                    name: "Admin".to_string(),
                    data: VariantData::Struct(vec![StructField {
                        name: "permissions".to_string(),
                        ty: RustType::Vec(Box::new(RustType::Primitive("String".to_string()))),
                    }]),
                },
                EnumVariant {
                    name: "User".to_string(),
                    data: VariantData::Unit,
                },
            ],
            source_file: test_path(),
            representation: EnumRepresentation::Internal { tag: "type".to_string() },
        };

        let ctx = default_ctx();
        let output = generate_enum_type(&e, &ctx);

        assert!(output.contains("type: \"Admin\""));
        assert!(output.contains("permissions: string[]"));
        assert!(output.contains("type: \"User\""));
    }

    #[test]
    fn test_camel_case_field_names() {
        let s = RustStruct {
            name: "User".to_string(),
            generics: vec![],
            fields: vec![
                StructField {
                    name: "user_id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
                StructField {
                    name: "first_name".to_string(),
                    ty: RustType::Primitive("String".to_string()),
                },
            ],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("userId: number"));
        assert!(output.contains("firstName: string"));
    }

    #[test]
    fn test_generate_empty_struct() {
        let s = RustStruct {
            name: "Empty".to_string(),
            generics: vec![],
            fields: vec![],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface Empty"));
        assert!(output.contains("{\n}\n"));
    }

    #[test]
    fn test_generate_types_file_header() {
        let output = generate_types_file(&[], &[], &default_ctx());

        assert!(output.contains("// This file was auto-generated by tauri-ts-generator"));
        assert!(output.contains("// Do not edit this file manually"));
    }

    #[test]
    fn test_generate_multiple_types() {
        let structs = vec![
            RustStruct {
                name: "User".to_string(),
                generics: vec![],
                fields: vec![StructField {
                    name: "id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                }],
                source_file: test_path(),
            },
            RustStruct {
                name: "Item".to_string(),
                generics: vec![],
                fields: vec![StructField {
                    name: "name".to_string(),
                    ty: RustType::Primitive("String".to_string()),
                }],
                source_file: test_path(),
            },
        ];

        let enums = vec![RustEnum {
            name: "Status".to_string(),
            generics: vec![],
            variants: vec![
                EnumVariant {
                    name: "Active".to_string(),
                    data: VariantData::Unit,
                },
            ],
            source_file: test_path(),
            representation: EnumRepresentation::default(),
        }];

        let ctx = default_ctx();
        let output = generate_types_file(&structs, &enums, &ctx);

        assert!(output.contains("export interface User"));
        assert!(output.contains("export interface Item"));
        assert!(output.contains("export type Status"));
    }

    #[test]
    fn test_type_with_option_field() {
        let s = RustStruct {
            name: "User".to_string(),
            generics: vec![],
            fields: vec![StructField {
                name: "email".to_string(),
                ty: RustType::Option(Box::new(RustType::Primitive("String".to_string()))),
            }],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("email: string | null"));
    }

    #[test]
    fn test_type_with_vec_field() {
        let s = RustStruct {
            name: "User".to_string(),
            generics: vec![],
            fields: vec![StructField {
                name: "tags".to_string(),
                ty: RustType::Vec(Box::new(RustType::Primitive("String".to_string()))),
            }],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("tags: string[]"));
    }

    #[test]
    fn test_naming_prefix() {
        let s = RustStruct {
            name: "User".to_string(),
            generics: vec![],
            fields: vec![],
            source_file: test_path(),
        };

        let ctx = GeneratorContext::new(NamingConfig {
            type_prefix: "I".to_string(),
            type_suffix: "".to_string(),
            function_prefix: "".to_string(),
            function_suffix: "".to_string(),
        });
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface IUser"));
    }
}
