use crate::models::{EnumRepresentation, RustEnum, RustStruct, VariantData};
use crate::utils::to_camel_case;

use super::{type_mapper::rust_to_typescript, GeneratorContext};

/// Generate TypeScript types file content
pub fn generate_types_file(
    structs: &[RustStruct],
    enums: &[RustEnum],
    ctx: &GeneratorContext,
) -> String {
    let mut output = String::new();

    // Add header comment
    output.push_str("// This file was auto-generated by tauri-ts-generator\n");
    output.push_str("// Do not edit this file manually\n\n");

    // Generate interfaces for structs
    for s in structs {
        output.push_str(&generate_interface(s, ctx));
        output.push('\n');
    }

    // Generate types for enums
    for e in enums {
        output.push_str(&generate_enum_type(e, ctx));
        output.push('\n');
    }

    output
}

/// Generate a TypeScript interface from a Rust struct
fn generate_interface(s: &RustStruct, ctx: &GeneratorContext) -> String {
    let mut output = String::new();

    let interface_name = ctx.format_type_name(&s.name);

    // Add generic parameters if present
    let generics_str = if s.generics.is_empty() {
        String::new()
    } else {
        format!("<{}>", s.generics.join(", "))
    };

    output.push_str(&format!(
        "export interface {}{} {{\n",
        interface_name, generics_str
    ));

    for field in &s.fields {
        // If use_optional is true and type is Option<T>, generate field?: T instead of field: T | null
        let (optional_marker, ts_type) = if field.use_optional {
            if let crate::models::RustType::Option(inner) = &field.ty {
                let ts_type = rust_to_typescript(inner, ctx);
                ("?", ts_type)
            } else {
                let ts_type = rust_to_typescript(&field.ty, ctx);
                ("", ts_type)
            }
        } else {
            let ts_type = rust_to_typescript(&field.ty, ctx);
            ("", ts_type)
        };
        // If serde rename was explicitly set, use the name as-is
        // Otherwise, convert to camelCase
        let field_name = if field.has_explicit_rename {
            field.name.clone()
        } else {
            to_camel_case(&field.name)
        };
        output.push_str(&format!(
            "  {}{}: {};\n",
            field_name, optional_marker, ts_type
        ));
    }

    output.push_str("}\n");

    output
}

/// Generate a TypeScript type from a Rust enum
fn generate_enum_type(e: &RustEnum, ctx: &GeneratorContext) -> String {
    let mut output = String::new();

    let type_name = ctx.format_type_name(&e.name);

    // Add generic parameters if present
    let generics_str = if e.generics.is_empty() {
        String::new()
    } else {
        format!("<{}>", e.generics.join(", "))
    };

    let variants: Vec<String> = e
        .variants
        .iter()
        .map(|variant| generate_variant(variant, &e.representation, ctx))
        .collect();

    if variants.is_empty() {
        output.push_str(&format!(
            "export type {}{} = never;\n",
            type_name, generics_str
        ));
    } else {
        output.push_str(&format!(
            "export type {}{} =\n  | {};\n",
            type_name,
            generics_str,
            variants.join("\n  | ")
        ));
    }

    output
}

fn generate_variant(
    variant: &crate::models::EnumVariant,
    representation: &EnumRepresentation,
    ctx: &GeneratorContext,
) -> String {
    match representation {
        EnumRepresentation::External => match &variant.data {
            VariantData::Unit => format!("\"{}\"", variant.name),
            VariantData::Tuple(types) => {
                let ts_types: Vec<_> = types.iter().map(|t| rust_to_typescript(t, ctx)).collect();
                let inner = if ts_types.len() == 1 {
                    ts_types[0].clone()
                } else {
                    format!("[{}]", ts_types.join(", "))
                };
                format!("{{ {}: {} }}", variant.name, inner)
            }
            VariantData::Struct(fields) => {
                let inner = generate_struct_body(fields, ctx);
                format!("{{ {}: {} }}", variant.name, inner)
            }
        },
        EnumRepresentation::Internal { tag } => {
            match &variant.data {
                VariantData::Unit => format!("{{ {}: \"{}\" }}", tag, variant.name),
                VariantData::Struct(fields) => {
                    let mut body = generate_struct_body(fields, ctx);
                    // Remove opening brace and insert tag
                    body.remove(0); // remove '{'
                    format!("{{ {}: \"{}\",{}", tag, variant.name, body)
                }
                VariantData::Tuple(_) => {
                    // Internal tagging doesn't support tuples strictly speaking (unless newtype around struct)
                    // We'll fallback to just the tag for now or maybe error?
                    // For safety let's just emit { tag: "Name" } & Partial<Tuple> ??
                    // Let's assume user knows what they are doing and it's likely not used with Tuples
                    format!("{{ {}: \"{}\" /* Tuple variants not fully supported in internal tagging */ }}", tag, variant.name)
                }
            }
        }
        EnumRepresentation::Adjacent { tag, content } => match &variant.data {
            VariantData::Unit => format!("{{ {}: \"{}\" }}", tag, variant.name),
            VariantData::Tuple(types) => {
                let ts_types: Vec<_> = types.iter().map(|t| rust_to_typescript(t, ctx)).collect();
                let inner = if ts_types.len() == 1 {
                    ts_types[0].clone()
                } else {
                    format!("[{}]", ts_types.join(", "))
                };
                format!(
                    "{{ {}: \"{}\"; {}: {} }}",
                    tag, variant.name, content, inner
                )
            }
            VariantData::Struct(fields) => {
                let inner = generate_struct_body(fields, ctx);
                format!(
                    "{{ {}: \"{}\"; {}: {} }}",
                    tag, variant.name, content, inner
                )
            }
        },
        EnumRepresentation::Untagged => match &variant.data {
            VariantData::Unit => "null".to_string(), // Untagged unit matches null? Or nothing? Serde says it errors if it can't match. Usually untagged is for matching shapes.
            VariantData::Tuple(types) => {
                let ts_types: Vec<_> = types.iter().map(|t| rust_to_typescript(t, ctx)).collect();
                if ts_types.len() == 1 {
                    ts_types[0].clone()
                } else {
                    format!("[{}]", ts_types.join(", "))
                }
            }
            VariantData::Struct(fields) => generate_struct_body(fields, ctx),
        },
    }
}

fn generate_struct_body(fields: &[crate::models::StructField], ctx: &GeneratorContext) -> String {
    let mut params = Vec::new();
    for field in fields {
        // If use_optional is true and type is Option<T>, generate field?: T instead of field: T | null
        let (optional_marker, ts_type) = if field.use_optional {
            if let crate::models::RustType::Option(inner) = &field.ty {
                let ts_type = rust_to_typescript(inner, ctx);
                ("?", ts_type)
            } else {
                let ts_type = rust_to_typescript(&field.ty, ctx);
                ("", ts_type)
            }
        } else {
            let ts_type = rust_to_typescript(&field.ty, ctx);
            ("", ts_type)
        };
        // If serde rename was explicitly set, use the name as-is
        // Otherwise, convert to camelCase
        let field_name = if field.has_explicit_rename {
            field.name.clone()
        } else {
            to_camel_case(&field.name)
        };
        params.push(format!("{}{}: {}", field_name, optional_marker, ts_type));
    }
    format!("{{ {} }}", params.join("; "))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::NamingConfig;
    use crate::models::{EnumVariant, RustType, StructField, VariantData};
    use std::path::PathBuf;

    fn test_path() -> PathBuf {
        PathBuf::from("test.rs")
    }

    fn default_ctx() -> GeneratorContext {
        GeneratorContext::new(NamingConfig::default())
    }

    #[test]
    fn test_generate_simple_interface() {
        let s = RustStruct {
            name: "User".to_string(),
            generics: vec![],
            fields: vec![
                StructField {
                    has_explicit_rename: false,
                    use_optional: false,
                    name: "id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
                StructField {
                    has_explicit_rename: false,
                    use_optional: false,
                    name: "name".to_string(),
                    ty: RustType::Primitive("String".to_string()),
                },
            ],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface User"));
        assert!(output.contains("id: number"));
        assert!(output.contains("name: string"));
    }

    #[test]
    fn test_generate_interface_with_generics() {
        let s = RustStruct {
            name: "Wrapper".to_string(),
            generics: vec!["T".to_string()],
            fields: vec![
                StructField {
                    has_explicit_rename: false,
                    use_optional: false,
                    name: "data".to_string(),
                    ty: RustType::Generic("T".to_string()),
                },
                StructField {
                    has_explicit_rename: false,
                    use_optional: false,
                    name: "count".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
            ],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface Wrapper<T>"));
        assert!(output.contains("data: T"));
        assert!(output.contains("count: number"));
    }

    #[test]
    fn test_generate_interface_with_multiple_generics() {
        let s = RustStruct {
            name: "Pair".to_string(),
            generics: vec!["K".to_string(), "V".to_string()],
            fields: vec![
                StructField {
                    has_explicit_rename: false,
                    use_optional: false,
                    name: "key".to_string(),
                    ty: RustType::Generic("K".to_string()),
                },
                StructField {
                    has_explicit_rename: false,
                    use_optional: false,
                    name: "value".to_string(),
                    ty: RustType::Generic("V".to_string()),
                },
            ],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface Pair<K, V>"));
    }

    #[test]
    fn test_generate_simple_enum() {
        let e = RustEnum {
            name: "Status".to_string(),
            generics: vec![],
            variants: vec![
                EnumVariant {
                    has_explicit_rename: false,
                    name: "Active".to_string(),
                    data: VariantData::Unit,
                },
                EnumVariant {
                    has_explicit_rename: false,
                    name: "Inactive".to_string(),
                    data: VariantData::Unit,
                },
                EnumVariant {
                    has_explicit_rename: false,
                    name: "Pending".to_string(),
                    data: VariantData::Unit,
                },
            ],
            source_file: test_path(),
            representation: EnumRepresentation::default(),
        };

        let ctx = default_ctx();
        let output = generate_enum_type(&e, &ctx);

        assert!(output.contains("export type Status ="));
        assert!(output.contains("\"Active\""));
        assert!(output.contains("\"Inactive\""));
        assert!(output.contains("\"Pending\""));
    }

    #[test]
    fn test_generate_complex_enum_with_tuple() {
        let e = RustEnum {
            name: "Message".to_string(),
            generics: vec![],
            variants: vec![
                EnumVariant {
                    has_explicit_rename: false,
                    name: "Text".to_string(),
                    data: VariantData::Tuple(vec![RustType::Primitive("String".to_string())]),
                },
                EnumVariant {
                    has_explicit_rename: false,
                    name: "Number".to_string(),
                    data: VariantData::Tuple(vec![RustType::Primitive("i32".to_string())]),
                },
            ],
            source_file: test_path(),
            representation: EnumRepresentation::default(),
        };

        let ctx = default_ctx();
        let output = generate_enum_type(&e, &ctx);

        assert!(output.contains("export type Message ="));
        // External representation: { Text: string } | { Number: number }
        assert!(output.contains("Text: string"));
        assert!(output.contains("Number: number"));
    }

    #[test]
    fn test_generate_complex_enum_with_struct() {
        let e = RustEnum {
            name: "UserRole".to_string(),
            generics: vec![],
            variants: vec![
                EnumVariant {
                    has_explicit_rename: false,
                    name: "Admin".to_string(),
                    data: VariantData::Struct(vec![StructField {
                        has_explicit_rename: false,
                        use_optional: false,
                        name: "permissions".to_string(),
                        ty: RustType::Vec(Box::new(RustType::Primitive("String".to_string()))),
                    }]),
                },
                EnumVariant {
                    has_explicit_rename: false,
                    name: "User".to_string(),
                    data: VariantData::Unit,
                },
            ],
            source_file: test_path(),
            representation: EnumRepresentation::Internal {
                tag: "type".to_string(),
            },
        };

        let ctx = default_ctx();
        let output = generate_enum_type(&e, &ctx);

        assert!(output.contains("type: \"Admin\""));
        assert!(output.contains("permissions: string[]"));
        assert!(output.contains("type: \"User\""));
    }

    #[test]
    fn test_camel_case_field_names() {
        let s = RustStruct {
            name: "User".to_string(),
            generics: vec![],
            fields: vec![
                StructField {
                    has_explicit_rename: false,
                    use_optional: false,
                    name: "user_id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
                StructField {
                    has_explicit_rename: false,
                    use_optional: false,
                    name: "first_name".to_string(),
                    ty: RustType::Primitive("String".to_string()),
                },
            ],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("userId: number"));
        assert!(output.contains("firstName: string"));
    }

    #[test]
    fn test_generate_empty_struct() {
        let s = RustStruct {
            name: "Empty".to_string(),
            generics: vec![],
            fields: vec![],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface Empty"));
        assert!(output.contains("{\n}\n"));
    }

    #[test]
    fn test_generate_types_file_header() {
        let output = generate_types_file(&[], &[], &default_ctx());

        assert!(output.contains("// This file was auto-generated by tauri-ts-generator"));
        assert!(output.contains("// Do not edit this file manually"));
    }

    #[test]
    fn test_generate_multiple_types() {
        let structs = vec![
            RustStruct {
                name: "User".to_string(),
                generics: vec![],
                fields: vec![StructField {
                    has_explicit_rename: false,
                    use_optional: false,
                    name: "id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                }],
                source_file: test_path(),
            },
            RustStruct {
                name: "Item".to_string(),
                generics: vec![],
                fields: vec![StructField {
                    has_explicit_rename: false,
                    use_optional: false,
                    name: "name".to_string(),
                    ty: RustType::Primitive("String".to_string()),
                }],
                source_file: test_path(),
            },
        ];

        let enums = vec![RustEnum {
            name: "Status".to_string(),
            generics: vec![],
            variants: vec![EnumVariant {
                has_explicit_rename: false,
                name: "Active".to_string(),
                data: VariantData::Unit,
            }],
            source_file: test_path(),
            representation: EnumRepresentation::default(),
        }];

        let ctx = default_ctx();
        let output = generate_types_file(&structs, &enums, &ctx);

        assert!(output.contains("export interface User"));
        assert!(output.contains("export interface Item"));
        assert!(output.contains("export type Status"));
    }

    #[test]
    fn test_type_with_option_field() {
        let s = RustStruct {
            name: "User".to_string(),
            generics: vec![],
            fields: vec![StructField {
                has_explicit_rename: false,
                use_optional: false,
                name: "email".to_string(),
                ty: RustType::Option(Box::new(RustType::Primitive("String".to_string()))),
            }],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("email: string | null"));
    }

    #[test]
    fn test_type_with_vec_field() {
        let s = RustStruct {
            name: "User".to_string(),
            generics: vec![],
            fields: vec![StructField {
                has_explicit_rename: false,
                use_optional: false,
                name: "tags".to_string(),
                ty: RustType::Vec(Box::new(RustType::Primitive("String".to_string()))),
            }],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("tags: string[]"));
    }

    #[test]
    fn test_naming_prefix() {
        let s = RustStruct {
            name: "User".to_string(),
            generics: vec![],
            fields: vec![],
            source_file: test_path(),
        };

        let ctx = GeneratorContext::new(NamingConfig {
            type_prefix: "I".to_string(),
            type_suffix: "".to_string(),
            function_prefix: "".to_string(),
            function_suffix: "".to_string(),
        });
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface IUser"));
    }

    #[test]
    fn test_field_explicit_rename_skips_camel_case() {
        // Struct with one normal field and one explicitly renamed field
        let s = RustStruct {
            name: "Config".to_string(),
            generics: vec![],
            fields: vec![
                StructField {
                    name: "user_name".to_string(), // Should become userName
                    ty: RustType::Primitive("String".to_string()),
                    has_explicit_rename: false,
                    use_optional: false,
                },
                StructField {
                    name: "API_KEY".to_string(), // Should succeed as API_KEY
                    ty: RustType::Primitive("String".to_string()),
                    has_explicit_rename: true, // Simulate #[serde(rename = "API_KEY")]
                    use_optional: false,
                },
                StructField {
                    name: "snake_case_kept".to_string(), // Should fail check if it was converted
                    ty: RustType::Primitive("bool".to_string()),
                    has_explicit_rename: true, // Simulate #[serde(rename = "snake_case_kept")]
                    use_optional: false,
                },
            ],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("userName: string"));
        assert!(output.contains("API_KEY: string"));
        assert!(!output.contains("apiKey: string"));
        assert!(output.contains("snake_case_kept: boolean"));
        assert!(!output.contains("snakeCaseKept: boolean"));
    }

    #[test]
    fn test_enum_variant_explicit_rename_skips_camel_case() {
        // Enum with mixed renamed and normal variants
        let e = RustEnum {
            name: "Status".to_string(),
            generics: vec![],
            variants: vec![
                EnumVariant {
                    name: "Active".to_string(),
                    data: VariantData::Unit,
                    has_explicit_rename: false,
                },
                EnumVariant {
                    name: "INACTIVE_STATE".to_string(),
                    data: VariantData::Unit,
                    has_explicit_rename: true, // Explicitly renamed
                },
            ],
            source_file: test_path(),
            representation: EnumRepresentation::default(),
        };

        let ctx = default_ctx();
        let output = generate_enum_type(&e, &ctx);

        assert!(output.contains("\"Active\""));
        assert!(output.contains("\"INACTIVE_STATE\""));
    }

    #[test]
    fn test_enum_struct_variant_field_rename() {
        let e = RustEnum {
            name: "Event".to_string(),
            generics: vec![],
            variants: vec![EnumVariant {
                name: "Login".to_string(),
                data: VariantData::Struct(vec![
                    StructField {
                        name: "user_id".to_string(),
                        ty: RustType::Primitive("i32".to_string()),
                        has_explicit_rename: false, // Normal conversion -> userId
                        use_optional: false,
                    },
                    StructField {
                        name: "TIMESTAMP".to_string(),
                        ty: RustType::Primitive("i64".to_string()),
                        has_explicit_rename: true, // Kept as TIMESTAMP
                        use_optional: false,
                    },
                ]),
                has_explicit_rename: false,
            }],
            source_file: test_path(),
            representation: EnumRepresentation::default(), // External tagging
        };

        let ctx = default_ctx();
        let output = generate_enum_type(&e, &ctx);

        assert!(output.contains("userId: number"));
        assert!(output.contains("TIMESTAMP: number"));
        assert!(!output.contains("timestamp: number"));
    }

    #[test]
    fn test_generate_ts_undefined_field() {
        let s = RustStruct {
            name: "Config".to_string(),
            generics: vec![],
            fields: vec![
                StructField {
                    name: "volume".to_string(),
                    ty: RustType::Option(Box::new(RustType::Primitive("f32".to_string()))),
                    has_explicit_rename: false,
                    use_optional: true,
                },
                StructField {
                    name: "name".to_string(),
                    ty: RustType::Option(Box::new(RustType::Primitive("String".to_string()))),
                    has_explicit_rename: false,
                    use_optional: false,
                },
            ],
            source_file: test_path(),
        };

        let ctx = default_ctx();
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("volume?: number"));
        assert!(output.contains("name: string | null"));
    }
}
