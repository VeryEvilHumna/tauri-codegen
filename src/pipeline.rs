//! Pipeline module - orchestrates the code generation process
//!
//! Flow: Scan -> Parse -> Resolve -> Collect -> Generate

use anyhow::{Context, Result};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};

use crate::cargo_expand::{find_cargo_manifest, run_cargo_expand};
use crate::config::Config;
use crate::generator::{
    commands_gen::generate_commands_file, types_gen::generate_types_file, GeneratorContext,
};
use crate::known_types;
use crate::models::{ParseResult, RustEnum, RustStruct, RustType};
use crate::parser::{parse_commands, parse_types, parse_types_expanded};
use crate::resolver::{ModuleResolver, ResolutionResult};
use crate::scanner::Scanner;

/// Result of type collection with potential conflicts
pub struct TypeCollectionResult {
    /// Successfully resolved types: name (as used in code) -> source file
    pub resolved: HashMap<String, PathBuf>,
    /// Conflicts: type name -> list of conflicting source files
    pub conflicts: HashMap<String, Vec<PathBuf>>,
    /// Unresolved types: type name -> file where it was used
    pub unresolved: HashMap<String, PathBuf>,
    /// Alias mappings: alias name (as used) -> original struct name (in source)
    /// This is needed for pub use X as Y re-exports
    pub alias_to_original: HashMap<String, String>,
}

/// Main pipeline for code generation
pub struct Pipeline {
    verbose: bool,
}

impl Pipeline {
    pub fn new(verbose: bool) -> Self {
        Self { verbose }
    }

    /// Run the full generation pipeline
    pub fn run(&self, config: &Config) -> Result<()> {
        if self.verbose {
            println!("Scanning directory: {}", config.input.source_dir.display());
        }

        // Step 1: Scan for Rust files
        let rust_files = self.scan_files(config)?;

        if self.verbose {
            println!("Found {} Rust files", rust_files.len());
        }

        // Step 1.5: Optionally run cargo expand for macro-generated types
        let expanded_code = if config.input.use_cargo_expand {
            self.run_cargo_expand(config)?
        } else {
            None
        };

        // Step 2: Parse all files and build resolver
        let (mut parse_result, resolver) = self.parse_files(&rust_files, config, expanded_code.as_deref())?;

        // Step 2.5: Filter out Tauri special types (State, Window, etc.) including aliases
        self.filter_tauri_special_args(&mut parse_result.commands, &resolver);

        // Step 3: Collect and resolve types used in commands
        let type_collection = self.collect_used_types(&parse_result, &resolver);

        // Step 4: Check for conflicts
        if !type_collection.conflicts.is_empty() {
            eprintln!("Error: Type name conflicts detected:");
            for (type_name, files) in &type_collection.conflicts {
                eprintln!("  Type '{}' is used from multiple sources:", type_name);
                for file in files {
                    eprintln!("    - {}", file.display());
                }
            }
            anyhow::bail!(
                "Found {} type name conflict(s). Please rename types or use explicit imports to avoid ambiguity.",
                type_collection.conflicts.len()
            );
        }

        // Step 4.5: Warn about unresolved types (likely macro-generated)
        if !type_collection.unresolved.is_empty() {
            println!(
                "Warning: {} type(s) could not be resolved and will not be generated:",
                type_collection.unresolved.len()
            );
            for (type_name, used_in) in &type_collection.unresolved {
                println!("  - '{}' (used in {})", type_name, used_in.display());
            }
            if !config.input.use_cargo_expand {
                println!();
                println!("Hint: These types may be generated by macros (e.g., progenitor, serde, etc.).");
                println!("      To include macro-generated types, add to your config:");
                println!("        [input]");
                println!("        use_cargo_expand = true");
                println!();
            }
        }

        // Step 5: Filter types based on resolution (including aliased types)
        let (filtered_structs, filtered_enums) =
            self.filter_types(&parse_result, &type_collection);

        // Summary
        println!(
            "Parsed {} commands, {} structs (used), {} enums (used)",
            parse_result.commands.len(),
            filtered_structs.len(),
            filtered_enums.len()
        );

        // Step 6: Generate TypeScript files
        self.generate_output(config, &parse_result, &filtered_structs, &filtered_enums)?;

        println!("Done!");

        Ok(())
    }

    /// Step 1: Scan for Rust files
    fn scan_files(&self, config: &Config) -> Result<Vec<PathBuf>> {
        let scanner = Scanner::new(
            config.input.source_dir.clone(),
            config.input.exclude.clone(),
        );
        scanner.scan()
    }

    /// Step 1.5: Run cargo expand if enabled
    fn run_cargo_expand(&self, config: &Config) -> Result<Option<String>> {
        println!("Warning: cargo expand is enabled. This will compile the project and may take a while.");
        println!("Warning: This is used to extract macro-generated types (e.g., from progenitor, serde, etc.)");

        // Find cargo manifest
        let manifest_path = config
            .input
            .cargo_manifest
            .clone()
            .or_else(|| find_cargo_manifest(&config.input.source_dir));

        let manifest_path = match manifest_path {
            Some(p) => p,
            None => {
                eprintln!(
                    "Warning: Could not find Cargo.toml for cargo expand. Skipping macro expansion."
                );
                return Ok(None);
            }
        };

        if self.verbose {
            eprintln!("Info: Using Cargo.toml at: {}", manifest_path.display());
        }

        // Run cargo expand
        let result = run_cargo_expand(&manifest_path)?;

        // Print all warnings
        for warning in &result.warnings {
            eprintln!("{}", warning);
        }

        if result.code.is_empty() {
            eprintln!("Warning: cargo expand produced no output. Continuing with regular parsing.");
            Ok(None)
        } else {
            Ok(Some(result.code))
        }
    }

    /// Step 2: Parse all files and build module resolver
    fn parse_files(
        &self,
        rust_files: &[PathBuf],
        config: &Config,
        expanded_code: Option<&str>,
    ) -> Result<(ParseResult, ModuleResolver)> {
        let mut resolver = ModuleResolver::new();
        let base_path = config.input.source_dir.clone();
        let mut parse_result = ParseResult::new();

        // If we have expanded code, parse types from it first
        if let Some(code) = expanded_code {
            let expanded_path = PathBuf::from("<cargo-expand>");
            
            // Parse types from expanded code (uses different detection for serde attrs)
            match parse_types_expanded(code, &expanded_path) {
                Ok((structs, enums)) => {
                    if self.verbose {
                        eprintln!(
                            "Info: Found {} structs and {} enums from cargo expand",
                            structs.len(),
                            enums.len()
                        );
                    }
                    
                    // Register types in resolver
                    for s in &structs {
                        resolver.register_expanded_type(&s.name, &expanded_path);
                    }
                    for e in &enums {
                        resolver.register_expanded_type(&e.name, &expanded_path);
                    }
                    
                    parse_result.structs.extend(structs);
                    parse_result.enums.extend(enums);
                }
                Err(e) => {
                    eprintln!(
                        "Warning: Failed to parse types from cargo expand output: {}",
                        e
                    );
                }
            }
        }

        for file_path in rust_files {
            let content = fs::read_to_string(file_path)
                .with_context(|| format!("Failed to read file: {}", file_path.display()))?;

            // Build resolver scope for this file
            if let Err(e) = resolver.parse_file(file_path, &content, &base_path) {
                if self.verbose {
                    eprintln!(
                        "Warning: Failed to parse imports in {}: {}",
                        file_path.display(),
                        e
                    );
                }
            }

            // Parse commands
            match parse_commands(&content, file_path) {
                Ok(commands) => {
                    if !commands.is_empty() && self.verbose {
                        println!(
                            "Found {} commands in {}",
                            commands.len(),
                            file_path.display()
                        );
                    }
                    parse_result.commands.extend(commands);
                }
                Err(e) => {
                    eprintln!(
                        "Warning: Failed to parse commands in {}: {}",
                        file_path.display(),
                        e
                    );
                }
            }

            // Parse types
            match parse_types(&content, file_path) {
                Ok((structs, enums)) => {
                    if self.verbose && (!structs.is_empty() || !enums.is_empty()) {
                        println!(
                            "Found {} structs and {} enums in {}",
                            structs.len(),
                            enums.len(),
                            file_path.display()
                        );
                    }
                    parse_result.structs.extend(structs);
                    parse_result.enums.extend(enums);
                }
                Err(e) => {
                    eprintln!(
                        "Warning: Failed to parse types in {}: {}",
                        file_path.display(),
                        e
                    );
                }
            }
        }

        Ok((parse_result, resolver))
    }

    /// Step 3: Collect all types used in commands, resolving their source files
    fn collect_used_types(
        &self,
        parse_result: &ParseResult,
        resolver: &ModuleResolver,
    ) -> TypeCollectionResult {
        let mut resolved_types: HashMap<String, PathBuf> = HashMap::new();
        let mut conflicts: HashMap<String, Vec<PathBuf>> = HashMap::new();
        let mut unresolved_types: HashMap<String, PathBuf> = HashMap::new();
        let mut alias_mappings: HashMap<String, String> = HashMap::new();

        // Build lookup maps: (name, source_file) -> type
        let struct_by_file: HashMap<(&str, &Path), &RustStruct> = parse_result
            .structs
            .iter()
            .map(|s| ((s.name.as_str(), s.source_file.as_path()), s))
            .collect();
        let enum_by_file: HashMap<(&str, &Path), &RustEnum> = parse_result
            .enums
            .iter()
            .map(|e| ((e.name.as_str(), e.source_file.as_path()), e))
            .collect();

        // Collect types from all commands, resolving source files
        for cmd in &parse_result.commands {
            let cmd_file = &cmd.source_file;

            for arg in &cmd.args {
                self.collect_types_with_resolver(
                    &arg.ty,
                    cmd_file,
                    resolver,
                    &mut resolved_types,
                    &mut conflicts,
                    &mut unresolved_types,
                    &mut alias_mappings,
                );
            }
            if let Some(ref ret_type) = cmd.return_type {
                self.collect_types_with_resolver(
                    ret_type,
                    cmd_file,
                    resolver,
                    &mut resolved_types,
                    &mut conflicts,
                    &mut unresolved_types,
                    &mut alias_mappings,
                );
            }
        }

        // Recursively add nested types
        let mut to_process: Vec<(String, PathBuf)> = resolved_types
            .iter()
            .map(|(name, path)| (name.clone(), path.clone()))
            .collect();
        let mut processed: HashSet<(String, PathBuf)> = HashSet::new();

        while let Some((type_name, type_file)) = to_process.pop() {
            let key = (type_name.clone(), type_file.clone());
            if processed.contains(&key) {
                continue;
            }
            processed.insert(key);

            // Helper closure to process a nested type
            let mut process_nested_type = |t: String| {
                match resolver.resolve_type(&t, &type_file) {
                    ResolutionResult::Found(source) => {
                        let simple_name = t.split("::").last().unwrap_or(&t).to_string();
                        if let Some(existing) = resolved_types.get(&simple_name) {
                            if existing != &source {
                                let conflict_list = conflicts
                                    .entry(simple_name.clone())
                                    .or_insert_with(|| vec![existing.clone()]);
                                if !conflict_list.contains(&source) {
                                    conflict_list.push(source);
                                }
                            }
                        } else {
                            resolved_types.insert(simple_name.clone(), source.clone());
                            to_process.push((simple_name, source));
                        }
                    }
                    ResolutionResult::FoundWithAlias(source, original_name) => {
                        let alias_name = t.split("::").last().unwrap_or(&t).to_string();
                        if !resolved_types.contains_key(&alias_name) {
                            resolved_types.insert(alias_name.clone(), source.clone());
                            alias_mappings.insert(alias_name.clone(), original_name.clone());
                            to_process.push((original_name, source));
                        }
                    }
                    ResolutionResult::Ambiguous(_) => {
                        eprintln!("Warning: Ambiguous type '{}' used in {}", t, type_file.display());
                    }
                    ResolutionResult::NotFound => {
                        let simple_name = t.split("::").last().unwrap_or(&t).to_string();
                        unresolved_types.insert(simple_name, type_file.clone());
                    }
                }
            };

            // Check if it's a struct in this file
            if let Some(s) = struct_by_file.get(&(type_name.as_str(), type_file.as_path())) {
                for field in &s.fields {
                    for t in collect_custom_types_from_rust_type(&field.ty) {
                        process_nested_type(t);
                    }
                }
            }

            // Check if it's an enum in this file
            if let Some(e) = enum_by_file.get(&(type_name.as_str(), type_file.as_path())) {
                for variant in &e.variants {
                    let nested_names = match &variant.data {
                        crate::models::VariantData::Unit => vec![],
                        crate::models::VariantData::Tuple(types) => types
                            .iter()
                            .flat_map(collect_custom_types_from_rust_type)
                            .collect(),
                        crate::models::VariantData::Struct(fields) => fields
                            .iter()
                            .flat_map(|f| collect_custom_types_from_rust_type(&f.ty))
                            .collect(),
                    };
                    for t in nested_names {
                        process_nested_type(t);
                    }
                }
            }
        }

        TypeCollectionResult {
            resolved: resolved_types,
            conflicts,
            unresolved: unresolved_types,
            alias_to_original: alias_mappings,
        }
    }

    /// Collect types from RustType, resolving source files via resolver
    #[allow(clippy::too_many_arguments)]
    fn collect_types_with_resolver(
        &self,
        ty: &RustType,
        from_file: &Path,
        resolver: &ModuleResolver,
        resolved: &mut HashMap<String, PathBuf>,
        conflicts: &mut HashMap<String, Vec<PathBuf>>,
        unresolved: &mut HashMap<String, PathBuf>,
        alias_mappings: &mut HashMap<String, String>,
    ) {
        match ty {
            RustType::Custom(name) => {
                match resolver.resolve_type(name, from_file) {
                    ResolutionResult::Found(source) => {
                        let simple_name = name.split("::").last().unwrap_or(name).to_string();
                        if let Some(existing) = resolved.get(&simple_name) {
                            // Check for conflict: same name, different source file
                            if existing != &source {
                                let conflict_list = conflicts
                                    .entry(simple_name.clone())
                                    .or_insert_with(|| vec![existing.clone()]);
                                if !conflict_list.contains(&source) {
                                    conflict_list.push(source);
                                }
                            }
                        } else {
                            resolved.insert(simple_name, source);
                        }
                    }
                    ResolutionResult::FoundWithAlias(source, original_name) => {
                        // This is a type accessed via alias (pub use X as Y)
                        let alias_name = name.split("::").last().unwrap_or(name).to_string();
                        if !resolved.contains_key(&alias_name) {
                            resolved.insert(alias_name.clone(), source);
                            // Record the mapping from alias to original name
                            alias_mappings.insert(alias_name, original_name);
                        }
                    }
                    ResolutionResult::Ambiguous(paths) => {
                        eprintln!("Warning: Ambiguous type '{}' in {}. Found in: {:?}", name, from_file.display(), paths);
                    }
                    ResolutionResult::NotFound => {
                        // Track unresolved types (likely macro-generated)
                        let simple_name = name.split("::").last().unwrap_or(name).to_string();
                        unresolved.insert(simple_name, from_file.to_path_buf());
                    }
                }
            }
            RustType::Vec(inner) => {
                self.collect_types_with_resolver(inner, from_file, resolver, resolved, conflicts, unresolved, alias_mappings)
            }
            RustType::Option(inner) => {
                self.collect_types_with_resolver(inner, from_file, resolver, resolved, conflicts, unresolved, alias_mappings)
            }
            RustType::Result(ok) => {
                self.collect_types_with_resolver(ok, from_file, resolver, resolved, conflicts, unresolved, alias_mappings)
            }
            RustType::HashMap { key, value } => {
                self.collect_types_with_resolver(key, from_file, resolver, resolved, conflicts, unresolved, alias_mappings);
                self.collect_types_with_resolver(value, from_file, resolver, resolved, conflicts, unresolved, alias_mappings);
            }
            RustType::Tuple(tuple_types) => {
                for t in tuple_types {
                    self.collect_types_with_resolver(t, from_file, resolver, resolved, conflicts, unresolved, alias_mappings);
                }
            }
            _ => {}
        }
    }

    /// Step 5: Filter structs and enums based on resolved types
    fn filter_types(
        &self,
        parse_result: &ParseResult,
        type_collection: &TypeCollectionResult,
    ) -> (Vec<RustStruct>, Vec<RustEnum>) {
        let used_types = &type_collection.resolved;
        let alias_mappings = &type_collection.alias_to_original;
        
        let mut filtered_structs: Vec<RustStruct> = Vec::new();
        let mut seen_struct_names: HashSet<String> = HashSet::new();

        // First pass: add structs by their original names
        for s in parse_result.structs.iter() {
            if seen_struct_names.contains(&s.name) {
                continue;
            }

            // Only include if this specific struct (by name AND source file) was resolved
            if let Some(resolved_file) = used_types.get(&s.name) {
                if &s.source_file == resolved_file {
                    seen_struct_names.insert(s.name.clone());
                    filtered_structs.push(s.clone());
                }
            }
        }

        // Second pass: add aliased structs from cargo-expand
        // For each alias -> original mapping, find the original struct and create an alias copy
        for (alias_name, original_name) in alias_mappings {
            if seen_struct_names.contains(alias_name) {
                continue;
            }
            
            // Find the original struct
            if let Some(original_struct) = parse_result.structs.iter().find(|s| &s.name == original_name) {
                // Create a copy with the alias name
                let mut aliased_struct = original_struct.clone();
                aliased_struct.name = alias_name.clone();
                seen_struct_names.insert(alias_name.clone());
                filtered_structs.push(aliased_struct);
            }
        }

        let mut filtered_enums: Vec<RustEnum> = Vec::new();
        let mut seen_enum_names: HashSet<String> = HashSet::new();

        for e in parse_result.enums.iter() {
            if seen_enum_names.contains(&e.name) {
                continue;
            }

            // Only include if this specific enum (by name AND source file) was resolved
            if let Some(resolved_file) = used_types.get(&e.name) {
                if &e.source_file == resolved_file {
                    seen_enum_names.insert(e.name.clone());
                    filtered_enums.push(e.clone());
                }
            }
        }

        // Add aliased enums from cargo-expand
        for (alias_name, original_name) in alias_mappings {
            if seen_enum_names.contains(alias_name) {
                continue;
            }
            
            if let Some(original_enum) = parse_result.enums.iter().find(|e| &e.name == original_name) {
                let mut aliased_enum = original_enum.clone();
                aliased_enum.name = alias_name.clone();
                seen_enum_names.insert(alias_name.clone());
                filtered_enums.push(aliased_enum);
            }
        }

        (filtered_structs, filtered_enums)
    }

    /// Step 6: Generate TypeScript output files
    fn generate_output(
        &self,
        config: &Config,
        parse_result: &ParseResult,
        filtered_structs: &[RustStruct],
        filtered_enums: &[RustEnum],
    ) -> Result<()> {
        // Create generator context
        let mut ctx = GeneratorContext::new(config.naming.clone());

        for s in filtered_structs {
            ctx.register_type(&s.name);
        }
        for e in filtered_enums {
            ctx.register_type(&e.name);
        }

        // Generate types.ts
        let types_content = generate_types_file(filtered_structs, filtered_enums, &ctx);

        if let Some(parent) = config.output.types_file.parent() {
            if !parent.exists() {
                fs::create_dir_all(parent)?;
            }
        }

        fs::write(&config.output.types_file, &types_content).with_context(|| {
            format!(
                "Failed to write types file: {}",
                config.output.types_file.display()
            )
        })?;

        println!("Generated: {}", config.output.types_file.display());

        // Generate commands.ts
        let commands_content = generate_commands_file(
            &parse_result.commands,
            &config.output.types_file,
            &config.output.commands_file,
            &ctx,
        );

        if let Some(parent) = config.output.commands_file.parent() {
            if !parent.exists() {
                fs::create_dir_all(parent)?;
            }
        }

        fs::write(&config.output.commands_file, &commands_content).with_context(|| {
            format!(
                "Failed to write commands file: {}",
                config.output.commands_file.display()
            )
        })?;

        println!("Generated: {}", config.output.commands_file.display());

        Ok(())
    }
    
    /// Step 2.5: Filter out Tauri special types from command arguments
    /// This handles both direct uses (State<T>) and type aliases (type MyState = State<T>)
    fn filter_tauri_special_args(
        &self,
        commands: &mut [crate::models::TauriCommand],
        resolver: &ModuleResolver,
    ) {
        for cmd in commands.iter_mut() {
            cmd.args.retain(|arg| {
                // Get the base type name from the RustType
                let type_name = match &arg.ty {
                    RustType::Custom(name) => {
                        // Extract just the type name (without path)
                        name.split("::").last().unwrap_or(name).to_string()
                    }
                    RustType::Unknown(name) => {
                        name.split("::").last().unwrap_or(name).to_string()
                    }
                    _ => return true, // Keep primitives, Vec, Option, etc.
                };
                
                // Check if it's directly a Tauri special type
                if known_types::is_tauri_special_type(&type_name) {
                    return false;
                }
                
                // Check if it's an alias to a Tauri special type
                if let Some(target) = resolver.resolve_alias_target(&type_name, &cmd.source_file) {
                    if known_types::is_tauri_special_type(&target) {
                        return false;
                    }
                }
                
                true
            });
        }
    }
}

/// Collect custom type names from a RustType (returns a Vec)
fn collect_custom_types_from_rust_type(ty: &RustType) -> Vec<String> {
    let mut types = HashSet::new();
    collect_custom_types_recursive(ty, &mut types);
    let mut result: Vec<String> = types.into_iter().collect();
    result.sort();
    result
}

fn collect_custom_types_recursive(ty: &RustType, types: &mut HashSet<String>) {
    match ty {
        RustType::Custom(name) => {
             types.insert(name.clone());
        }
        RustType::Vec(inner) => collect_custom_types_recursive(inner, types),
        RustType::Option(inner) => collect_custom_types_recursive(inner, types),
        RustType::Result(ok) => collect_custom_types_recursive(ok, types),
        RustType::HashMap { key, value } => {
            collect_custom_types_recursive(key, types);
            collect_custom_types_recursive(value, types);
        }
        RustType::Tuple(tuple_types) => {
            for t in tuple_types {
                collect_custom_types_recursive(t, types);
            }
        }
        _ => {}
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::{CommandArg, EnumRepresentation, EnumVariant, StructField, TauriCommand, VariantData};

    fn test_path() -> PathBuf {
        PathBuf::from("test.rs")
    }

    #[test]
    fn test_collect_custom_types_simple() {
        let ty = RustType::Custom("User".to_string());
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["User"]);
    }

    #[test]
    fn test_collect_custom_types_primitive() {
        let ty = RustType::Primitive("String".to_string());
        let types = collect_custom_types_from_rust_type(&ty);
        assert!(types.is_empty());
    }

    #[test]
    fn test_collect_custom_types_vec() {
        let ty = RustType::Vec(Box::new(RustType::Custom("Item".to_string())));
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["Item"]);
    }

    #[test]
    fn test_collect_custom_types_option() {
        let ty = RustType::Option(Box::new(RustType::Custom("User".to_string())));
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["User"]);
    }

    #[test]
    fn test_collect_custom_types_result() {
        let ty = RustType::Result(Box::new(RustType::Custom("Response".to_string())));
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["Response"]);
    }

    #[test]
    fn test_collect_custom_types_hashmap() {
        let ty = RustType::HashMap {
            key: Box::new(RustType::Primitive("String".to_string())),
            value: Box::new(RustType::Custom("User".to_string())),
        };
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["User"]);
    }

    #[test]
    fn test_collect_custom_types_tuple() {
        let ty = RustType::Tuple(vec![
            RustType::Custom("User".to_string()),
            RustType::Custom("Item".to_string()),
            RustType::Primitive("i32".to_string()),
        ]);
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["Item", "User"]);
    }

    #[test]
    fn test_collect_custom_types_nested() {
        let ty = RustType::Vec(Box::new(RustType::Option(Box::new(RustType::Custom(
            "User".to_string(),
        )))));
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["User"]);
    }

    #[test]
    fn test_collect_custom_types_no_duplicates() {
        let ty = RustType::Tuple(vec![
            RustType::Custom("User".to_string()),
            RustType::Custom("User".to_string()),
        ]);
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["User"]);
    }

    /// Helper to create a simple TypeCollectionResult for testing
    fn make_type_collection(resolved: HashMap<String, PathBuf>) -> TypeCollectionResult {
        TypeCollectionResult {
            resolved,
            conflicts: HashMap::new(),
            unresolved: HashMap::new(),
            alias_to_original: HashMap::new(),
        }
    }

    #[test]
    fn test_filter_types_includes_used() {
        let pipeline = Pipeline::new(false);

        let parse_result = ParseResult {
            commands: vec![],
            structs: vec![
                RustStruct {
                    name: "User".to_string(),
                    generics: vec![],
                    fields: vec![],
                    source_file: PathBuf::from("src/types.rs"),
                },
                RustStruct {
                    name: "Item".to_string(),
                    generics: vec![],
                    fields: vec![],
                    source_file: PathBuf::from("src/types.rs"),
                },
            ],
            enums: vec![],
        };

        let mut used_types = HashMap::new();
        used_types.insert("User".to_string(), PathBuf::from("src/types.rs"));

        let (filtered_structs, _) = pipeline.filter_types(&parse_result, &make_type_collection(used_types));

        assert_eq!(filtered_structs.len(), 1);
        assert_eq!(filtered_structs[0].name, "User");
    }

    #[test]
    fn test_filter_types_excludes_unused() {
        let pipeline = Pipeline::new(false);

        let parse_result = ParseResult {
            commands: vec![],
            structs: vec![RustStruct {
                name: "UnusedType".to_string(),
                generics: vec![],
                fields: vec![],
                source_file: test_path(),
            }],
            enums: vec![],
        };

        let used_types = HashMap::new(); // Empty - no types used

        let (filtered_structs, _) = pipeline.filter_types(&parse_result, &make_type_collection(used_types));

        assert!(filtered_structs.is_empty());
    }

    #[test]
    fn test_filter_types_respects_source_file() {
        let pipeline = Pipeline::new(false);

        let parse_result = ParseResult {
            commands: vec![],
            structs: vec![
                RustStruct {
                    name: "User".to_string(),
                    generics: vec![],
                    fields: vec![],
                    source_file: PathBuf::from("src/a.rs"),
                },
                RustStruct {
                    name: "User".to_string(),
                    generics: vec![],
                    fields: vec![],
                    source_file: PathBuf::from("src/b.rs"),
                },
            ],
            enums: vec![],
        };

        let mut used_types = HashMap::new();
        // Only src/a.rs version is used
        used_types.insert("User".to_string(), PathBuf::from("src/a.rs"));

        let (filtered_structs, _) = pipeline.filter_types(&parse_result, &make_type_collection(used_types));

        assert_eq!(filtered_structs.len(), 1);
        assert_eq!(filtered_structs[0].source_file, PathBuf::from("src/a.rs"));
    }

    #[test]
    fn test_filter_enums() {
        let pipeline = Pipeline::new(false);

        let parse_result = ParseResult {
            commands: vec![],
            structs: vec![],
            enums: vec![
                RustEnum {
                    name: "Status".to_string(),
                    generics: vec![],
                    variants: vec![EnumVariant { has_explicit_rename: false,
                        name: "Active".to_string(),
                        data: VariantData::Unit,
                    }],
                    source_file: PathBuf::from("src/types.rs"),
                    representation: EnumRepresentation::default(),
                },
                RustEnum {
                    name: "UnusedEnum".to_string(),
                    generics: vec![],
                    variants: vec![],
                    source_file: PathBuf::from("src/types.rs"),
                    representation: EnumRepresentation::default(),
                },
            ],
        };

        let mut used_types = HashMap::new();
        used_types.insert("Status".to_string(), PathBuf::from("src/types.rs"));

        let (_, filtered_enums) = pipeline.filter_types(&parse_result, &make_type_collection(used_types));

        assert_eq!(filtered_enums.len(), 1);
        assert_eq!(filtered_enums[0].name, "Status");
    }

    #[test]
    fn test_type_collection_detects_conflicts() {
        let pipeline = Pipeline::new(false);
        let mut resolver = ModuleResolver::new();

        // Two files defining User
        let code_a = r#"
            pub struct User { pub id: i32 }
        "#;
        resolver
            .parse_file(&PathBuf::from("src/a.rs"), code_a, &PathBuf::from("src"))
            .unwrap();

        let code_b = r#"
            pub struct User { pub name: String }
        "#;
        resolver
            .parse_file(&PathBuf::from("src/b.rs"), code_b, &PathBuf::from("src"))
            .unwrap();

        // Commands file that uses User but doesn't import explicitly
        let code_cmd = r#"
            fn some_fn() {}
        "#;
        resolver
            .parse_file(
                &PathBuf::from("src/commands.rs"),
                code_cmd,
                &PathBuf::from("src"),
            )
            .unwrap();

        let parse_result = ParseResult {
            commands: vec![
                TauriCommand {
                    name: "get_user_a".to_string(),
                    args: vec![],
                    return_type: Some(RustType::Custom("User".to_string())),
                    source_file: PathBuf::from("src/a.rs"),
                    rename_all: None,
                },
                TauriCommand {
                    name: "get_user_b".to_string(),
                    args: vec![],
                    return_type: Some(RustType::Custom("User".to_string())),
                    source_file: PathBuf::from("src/b.rs"),
                    rename_all: None,
                },
            ],
            structs: vec![
                RustStruct {
                    name: "User".to_string(),
                    generics: vec![],
                    fields: vec![StructField { has_explicit_rename: false, use_optional: false,
                        name: "id".to_string(),
                        ty: RustType::Primitive("i32".to_string()),
                    }],
                    source_file: PathBuf::from("src/a.rs"),
                },
                RustStruct {
                    name: "User".to_string(),
                    generics: vec![],
                    fields: vec![StructField { has_explicit_rename: false, use_optional: false,
                        name: "name".to_string(),
                        ty: RustType::Primitive("String".to_string()),
                    }],
                    source_file: PathBuf::from("src/b.rs"),
                },
            ],
            enums: vec![],
        };

        let result = pipeline.collect_used_types(&parse_result, &resolver);

        // Should detect a conflict since User comes from two different files
        assert!(result.conflicts.contains_key("User"));
    }

    #[test]
    fn test_type_collection_no_conflicts_single_source() {
        let pipeline = Pipeline::new(false);
        let mut resolver = ModuleResolver::new();

        let types_code = r#"
            pub struct User { pub id: i32 }
        "#;
        resolver
            .parse_file(
                &PathBuf::from("src/types.rs"),
                types_code,
                &PathBuf::from("src"),
            )
            .unwrap();

        let parse_result = ParseResult {
            commands: vec![TauriCommand {
                name: "get_user".to_string(),
                args: vec![],
                return_type: Some(RustType::Custom("User".to_string())),
                source_file: PathBuf::from("src/types.rs"),
                rename_all: None,
            }],
            structs: vec![RustStruct {
                name: "User".to_string(),
                generics: vec![],
                fields: vec![],
                source_file: PathBuf::from("src/types.rs"),
            }],
            enums: vec![],
        };

        let result = pipeline.collect_used_types(&parse_result, &resolver);

        assert!(result.conflicts.is_empty());
        assert!(result.resolved.contains_key("User"));
    }

    #[test]
    fn test_pipeline_verbose_mode() {
        let pipeline = Pipeline::new(true);
        assert!(pipeline.verbose);

        let pipeline = Pipeline::new(false);
        assert!(!pipeline.verbose);
    }

    #[test]
    fn test_collect_types_from_args_and_return() {
        let pipeline = Pipeline::new(false);
        let mut resolver = ModuleResolver::new();

        let code = r#"
            pub struct Request { pub data: String }
            pub struct Response { pub result: i32 }
        "#;
        resolver
            .parse_file(
                &PathBuf::from("src/types.rs"),
                code,
                &PathBuf::from("src"),
            )
            .unwrap();

        let parse_result = ParseResult {
            commands: vec![TauriCommand {
                name: "process".to_string(),
                args: vec![CommandArg {
                    name: "req".to_string(),
                    ty: RustType::Custom("Request".to_string()),
                }],
                return_type: Some(RustType::Custom("Response".to_string())),
                source_file: PathBuf::from("src/types.rs"),
                rename_all: None,
            }],
            structs: vec![
                RustStruct {
                    name: "Request".to_string(),
                    generics: vec![],
                    fields: vec![],
                    source_file: PathBuf::from("src/types.rs"),
                },
                RustStruct {
                    name: "Response".to_string(),
                    generics: vec![],
                    fields: vec![],
                    source_file: PathBuf::from("src/types.rs"),
                },
            ],
            enums: vec![],
        };

        let result = pipeline.collect_used_types(&parse_result, &resolver);

        assert!(result.resolved.contains_key("Request"));
        assert!(result.resolved.contains_key("Response"));
    }

    #[test]
    fn test_filter_tauri_special_types() {
        let pipeline = Pipeline::new(false);
        let resolver = ModuleResolver::new();

        // Create a command with special Tauri types
        let mut commands = vec![TauriCommand {
            name: "test_command".to_string(),
            args: vec![
                CommandArg {
                    name: "state".to_string(),
                    ty: RustType::Custom("State".to_string()),
                },
                CommandArg {
                    name: "window".to_string(),
                    ty: RustType::Custom("Window".to_string()),
                },
                CommandArg {
                    name: "id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
            ],
            return_type: None,
            source_file: test_path(),
            rename_all: None,
        }];

        pipeline.filter_tauri_special_args(&mut commands, &resolver);

        // State and Window should be filtered out
        assert_eq!(commands[0].args.len(), 1);
        assert_eq!(commands[0].args[0].name, "id");
    }

    #[test]
    fn test_filter_tauri_app_handle() {
        let pipeline = Pipeline::new(false);
        let resolver = ModuleResolver::new();

        let mut commands = vec![TauriCommand {
            name: "with_app".to_string(),
            args: vec![
                CommandArg {
                    name: "app".to_string(),
                    ty: RustType::Custom("AppHandle".to_string()),
                },
                CommandArg {
                    name: "data".to_string(),
                    ty: RustType::Primitive("String".to_string()),
                },
            ],
            return_type: None,
            source_file: test_path(),
            rename_all: None,
        }];

        pipeline.filter_tauri_special_args(&mut commands, &resolver);

        // AppHandle should be filtered out
        assert_eq!(commands[0].args.len(), 1);
        assert_eq!(commands[0].args[0].name, "data");
    }

    #[test]
    fn test_filter_tauri_special_types_via_alias() {
        let pipeline = Pipeline::new(false);
        let mut resolver = ModuleResolver::new();

        // Register a type alias: type MyState = State<AppState>
        let code = "pub type MyState<'a> = State<'a, AppState>;";
        let path = test_path();
        resolver.parse_file(&path, code, &PathBuf::from(".")).unwrap();

        let mut commands = vec![TauriCommand {
            name: "aliased_command".to_string(),
            args: vec![
                CommandArg {
                    name: "state".to_string(),
                    ty: RustType::Custom("MyState".to_string()),
                },
                CommandArg {
                    name: "id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
            ],
            return_type: None,
            source_file: path.clone(),
            rename_all: None,
        }];

        pipeline.filter_tauri_special_args(&mut commands, &resolver);

        // MyState (alias to State) should be filtered out
        assert_eq!(commands[0].args.len(), 1);
        assert_eq!(commands[0].args[0].name, "id");
    }
}

